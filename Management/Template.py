'''
Project templates, including:
    * functions: manager, config, gitignore, license, tba, ed, vca, dmrg
'''

__all__=['manager','config','tba','ed','vca','dmrg']

def manager():
    return  [
            "from HamiltonianPy import *",
            "from HamiltonianPy.Misc import mpirun",
            "from source import *",
            "import numpy as np",
            "import mkl",
            "",
            "mkl.set_num_threads(1)",
            "",
            "# When using log files, set it to be False",
            "Engine.DEBUG=True",
            "",
            "# Run the engines. Replace 'f' with the correct function",
            "#mpirn(f,parameters,bcast=True)",
            ]

def config():
    return  [
            "from HamiltonianPy import *",
            "",
            "__all__=['name','nneighbour','idfmap','qnsmap']",
            "",
            "# The configs of the model",
            "name=",
            "nneighbour=",
            "",
            "# idfmap",
            "idfmap=lambda pid: None",
            "",
            "# qnsmap",
            "qnsmap=lambda index: None",
            ]

def tba():
    return  [
            "import numpy as np",
            "import HamiltonianPy.FreeSystem as TBA",
            "from HamiltonianPy import *",
            "from config import *",
            "",
            "__all__=['tbaconstruct']",
            "",
            "def tbaconstruct(parameters,lattice,**karg):",
            "    config=IDFConfig(priority=DEFAULT_FERMIONIC_PRIORITY,pids=lattice.pids,map=idfmap)",
            "    tba=TBA.TBA(",
            "        dout=       'result/tba',",
            "        name=       '%s_%s'%(name,lattice.name),",
            "        lattice=    lattice,",
            "        config=     config,",
            "        terms=[",
            "                    ],",
            "        )",
            "    tba.register()",
            "    tba.summary()",
            ]

def ed():
    return  [
            "import numpy as np",
            "import HamiltonianPy.ED as ED",
            "from HamiltonianPy import *",
            "from config import *",
            "",
            "__all__=['edconstruct']",
            "",
            "def edconstruct(parameters,basis,lattice,**karg):",
            "    config=IDFConfig(priority=DEFAULT_FERMIONIC_PRIORITY,pids=lattice.pids,map=idfmap)",
            "    ed=ED.ED(",
            "        dout=       'result/ed',",
            "        din=        'data/ed',",
            "        name=       '%s_%s_%s'%(name,lattice.name,basis.rep),",
            "        basis=      basis,",
            "        lattice=    lattice,",
            "        config=     config,",
            "        terms=[",
            "                    ],",
            "        )",
            "    ed.register()",
            "    ed.summary()",
            ]

def vca():
    return  [
            "import numpy as np",
            "import HamiltonianPy.ED as ED",
            "import HamiltonianPy.VCA as VCA",
            "from HamiltonianPy import *",
            "from config import *",
            "",
            "__all__=['vcaconstruct']",
            "",
            "def vcaconstruct(parameters,basis,cell,lattice,**karg):",
            "    config=IDFConfig(priority=DEFAULT_FERMIONIC_PRIORITY,pids=lattice.pids,map=idfmap)",
            "    cgf=ED.GF(operators=fspoperators(config.table(),lattice),nspin=,mask=,nstep=,save_data=,prepare=ED.EDGFP,run=ED.EDGF)",
            "    vca=VCA.VCA(",
            "        dout=       'result/vca',",
            "        din=        'data/vca',",
            "        cgf=        cgf,",
            "        name=       '%s_%s_%s'%(name,lattice.name,basis.rep),",
            "        basis=      basis,",
            "        cell=       cell,",
            "        lattice=    lattice,",
            "        config=     config,",
            "        terms=[",
            "                    ],",
            "        weiss=[",
            "                    ],",
            "        )",
            "    vca.register()",
            "    vca.summary()",
            ]

def dmrg():
    return  [
            "import numpy as np",
            "import HamiltonianPy.DMRG as DMRG",
            "from HamiltonianPy import *",
            "from HamiltonianPy.TensorNetwork import *",
            "from config import *",
            "",
            "__all__=['dmrgconstruct']",
            "",
            "def dmrgconstruct(parameters,lattice,nb,targets,core='idmrg',**karg):",
            "    priority,layers,mask=",
            "    dmrg=DMRG.DMRG(",
            "        log=        Log('log/%s-%s-%s-%s.log'%(name,lattice.name.replace('+',str(2*len(targets))),'_'.join(str(p) for p in parameters),repr(targets[-1]))),",
            "        din=        'data/dmrg',",
            "        dout=       'result/dmrg',",
            "        name=       '%s-%s'%(name,lattice.name),",
            "        mps=        MPS(mode='NB' if targets[-1] is None else 'QN'),",
            "        lattice=    lattice,",
            "        config=     IDFConfig(priority=priority,map=idfmap),",
            "        degfres=    DegFreTree(mode='NB' if targets[-1] is None else 'QN',priority=priority,layers=layers,map=qnsmap),",
            "        terms=[",
            "                    ],",
            "        mask=       mask,",
            "        dtype=      np.complex128",
            "        )",
            "    if core=='idmrg':",
            "        tsg=DMRG.TSG(name='GROWTH',targets=targets,nspb=,nmax=,run=DMRG.DMRGTSG)",
            "        dmrg.register(tsg)",
            "    elif core=='fdmrg':",
            "        tsg=DMRG.TSG(name='GROWTH',targets=targets,nspb=,nmax=,plot=False,run=DMRG.DMRGTSG)",
            "        tss=DMRG.TSS(name='SWEEP',target=targets[-1],nsite=,nmaxs=,dependences=[tsg],run=DMRGTSS)",
            "        dmrg.register(tss)",
            "    dmrg.summary()",
            ]
